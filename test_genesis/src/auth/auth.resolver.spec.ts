import { Test, TestingModule } from '@nestjs/testing';
import { AuthService } from './auth.service';
import { UserService } from '../user/user.service';
import { AuthResolver } from './auth.resolver';
import {
  MessageResponse,
  UserWithDetailsWithoutPassword,
} from './types/auth.type';
import { UserRoles } from '../user/enums/user-role.enum';
import { JwtService } from '@nestjs/jwt';
import { ApolloError } from 'apollo-server-express';
import { BadRequestException } from '@nestjs/common';
import { CurrentUserType } from '../user/types/user.type';
import { CreateUserInput } from '../user/dto/create-user.input';
import { User } from '../user/entities/user.entity';
import { UserStatus } from '../user/enums/user-status.enum';

describe('AuthResolver', () => {
  let resolver: AuthResolver;
  let authService: AuthService;
  let userServiceMock: UserService;
  let jwtServiceMock: JwtService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthResolver,
        {
          provide: AuthService,
          useValue: { generateToken: jest.fn(), invalidateToken: jest.fn() },
        }, // Mock AuthService
        {
          provide: UserService,
          useValue: {
            create: jest.fn(),
            isPasswordExpectedInResponseData: jest.fn(),
          },
        }, // Mock UserService
        { provide: JwtService, useValue: jwtServiceMock },
      ],
    }).compile();

    resolver = module.get<AuthResolver>(AuthResolver);
    authService = module.get<AuthService>(AuthService);
    userServiceMock = module.get<UserService>(UserService);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  describe('signIn', () => {
    it('should return a token', async () => {
      const user: CurrentUserType = {
        id: 1,
        role: UserRoles.USER,
      };
      jest
        .spyOn(authService, 'generateToken')
        .mockImplementation(() => Promise.resolve({ access_token: 'token' }));
      expect(
        (await resolver.logIn('test@example.com', 'password', user))
          .access_token,
      ).toBe('token');
    });
  });

  describe('signUp', () => {
    it('should sign up a user', async () => {
      const createUserInput: CreateUserInput = {
        username: 'guest8',
        email: 'test15@gmail.com',
        password: 'passwordA123*',
        confirm: 'passwordA123*',
      };

      const expectedUser: User = {
        id: 1,
        role: UserRoles.USER,
        status: UserStatus.ACTIVE,
        createdAt: new Date(), // Assuming these values are auto-generated by the database
        updatedAt: new Date(),
        details: {
          id: 1,
          username: 'guest8',
          email: 'test15@gmail.com',
          // Add other required properties from UserDetails entity
          password: 'hashedPassword',
          fullname: 'John Doe',
          age: 30,
          user: null,
          createdAt: new Date(),
          updatedAt: new Date(),
        },
      };

      const info: any = {
        fieldNodes: [
          {
            selectionSet: {
              selections: [
                {
                  name: {
                    value: 'id', // Mocking the selected field
                  },
                },
              ],
            },
          },
        ],
      };

      // Mock userService methods
      jest
        .spyOn(userServiceMock, 'isPasswordExpectedInResponseData')
        .mockReturnValue(false);
      jest.spyOn(userServiceMock, 'create').mockResolvedValue(expectedUser);

      // Test the signUp method
      const result = await resolver.signUp(createUserInput, info);

      expect(result).toEqual(expectedUser);
      expect(
        userServiceMock.isPasswordExpectedInResponseData,
      ).toHaveBeenCalledWith(info);
      expect(userServiceMock.create).toHaveBeenCalledWith(createUserInput);
    });

    it('should throw an error if password field is expected in response data', async () => {
      const createUserInput: CreateUserInput = {
        username: 'guest8',
        email: 'test15@gmail.com',
        password: 'passwordA123*',
        confirm: 'passwordA123*',
      };

      const info: any = {
        fieldNodes: [
          {
            selectionSet: {
              selections: [
                {
                  name: {
                    value: 'password', // Mocking the selected field
                  },
                },
              ],
            },
          },
        ],
      };

      // Mock userService methods
      jest
        .spyOn(userServiceMock, 'isPasswordExpectedInResponseData')
        .mockReturnValue(true);

      // Test for throwing BadRequestException
      await expect(resolver.signUp(createUserInput, info)).rejects.toThrow(
        BadRequestException,
      );
    });

    it('should throw an ApolloError for other errors', async () => {
      const createUserInput: CreateUserInput = {
        username: 'guest8',
        email: 'test15@gmail.com',
        password: 'passwordA123*',
        confirm: 'passwordA123*',
      };

      const info: any = {
        fieldNodes: [
          {
            selectionSet: {
              selections: [
                {
                  name: {
                    value: 'id', // Mocking the selected field
                  },
                },
              ],
            },
          },
        ],
      };

      // Mock userService methods
      jest
        .spyOn(userServiceMock, 'isPasswordExpectedInResponseData')
        .mockImplementation(() => {
          throw new Error(); // Simulating an internal error
        });

      // Test for throwing ApolloError
      await expect(resolver.signUp(createUserInput, info)).rejects.toThrow(
        ApolloError,
      );
    });
  });

  describe('signOut', () => {
    it('should sign out successfully with a valid token', async () => {
      const mockReq = {
        headers: {
          authorization: 'Bearer validToken',
        },
      };

      const expectedResult: MessageResponse = {
        message: 'Sign out has been successfully',
      };

      jest
        .spyOn(authService, 'invalidateToken')
        .mockResolvedValueOnce(undefined);

      const result = await resolver.signOut(mockReq);

      expect(result).toEqual(expectedResult);
    });

    it('should throw an error if no token is provided', async () => {
      const mockReq = {
        headers: {},
      };

      await expect(resolver.signOut(mockReq)).rejects.toThrowError(ApolloError);
    });
  });
});
